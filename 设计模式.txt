为什么要用单例模式呢？
     只想生成该类的一个对象。 有4中方式， 懒汉式，饿汉式，静态内部类，枚举      类型。
     通过2种方式(序列化和反序列化，反射)可以打破这种规则，但是可以杜绝。
          反序列化后，如果定义了readResolve（）则直接返回此方法指定的对象，          而不需要单独再创建新对象
      CountDownLatch， counDown(), await()

为什么要用工厂模式呢？
      调用者和创建者相分离。  简单工厂模式，工厂方法模式，抽象工厂模式

为什么要用建造者模式呢？
      当一个对象的构造太过复杂，主要由2部分组成，Builder，Director。 开发中        的应用场景，StringBuilder类的append方法，SQL中的PreparedStatement

为什么要使用原型模式呢？
      因为new一个对象太耗费时间。 有2中方式， 对象的clone，实体类需要实现        cloneable接口。 对象的序列化和反序列化，实体类需要实现Serializable接口

适配模式
      使原本由于接口不兼容不能一起工作的类可以一起工作

代理模式
     为真实对象提供一个代理，从而控制对真实对象的访问。
     静态代理模式:  真实对象和代理对象实现了抽象角色接口，但是代理对象中有真实对象的引用。
     动态代理模式:  借用jdk的 InvocationHandler，Proxy 来完成代理对象的组装

